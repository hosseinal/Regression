# -*- coding: utf-8 -*-
"""PolnomialRegression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fkYbISyHv1Nep1Mqw7THJZ5HwmTGjWRB
"""

import numpy as np
import math
import pandas as pd
import random
from itertools import combinations_with_replacement
import matplotlib.pyplot as plt



#link of dataset : https://www.kaggle.com/budincsevity/szeged-weather



class polynomialRegression () :

  def __init__( self, degree) :  
        self.degree = degree
        self.design_matrix = []
        self.coefficients = []
        self.w = []

  #Polynomial Base Function
  #this function get a row and affect the base function on the row
  def polynomial_baseFunction(self , row) :
    if len(self.coefficients) == 0 :
      coefficients = []
      for i in range(1 ,self.degree+1) :
        x = list(combinations_with_replacement(range(0, len(row)), i))
        coefficients = coefficients + x
      self.coefficients = coefficients        
    transformed_row = []
    transformed_row.append(1)
    for item in self.coefficients :
        varient = 1
        for element in item :
          varient = row[element] * varient
        transformed_row.append(varient)
    return transformed_row

  #generate design matrix
  def generate_design_matrix(self ,raw_data):
    matrix = []
    for row in raw_data :
      transformed_row = self.polynomial_baseFunction(row)
      matrix.append(list(transformed_row))
    self.design_matrix = matrix

  def least_squers_solver(self,A, b) :
    self.w = np.linalg.lstsq(A , b , rcond=None)[0]

  def fit (self ,X , Y) :
    #generate design matrix
    self.generate_design_matrix(X)

    #solve the AX = b
    self.least_squers_solver(self.design_matrix,Y)

  #predict model data using fitted model
  def predict (self,x_test) :
    Y_pred = [] 
    for row in x_test :
      transformed_row = self.polynomial_baseFunction(row)
      varient = 0
      for i in range(len(self.w))  :
        varient = varient + transformed_row[i] * self.w[i] 
      Y_pred.append(varient)
    return Y_pred

  #this is error function
  def sum_of_error (self ,Y , Y_pred) :
    varient = 0
    for i in range(len(Y)) :
      p = pow(Y[i] - Y_pred[i] , 2)
      if math.isnan(p) == False :
        varient = varient + p
    return varient / 2

  #calculate RMSD 
  def root_mean_square_deviation(self ,Y , Y_pred) :
    return math.sqrt(2 * self.sum_of_error(Y,Y_pred) / len(Y))

def generate_data_sin(size):
    train_data = generate_fake_sin(size)
    train_x , train_y = train_data[:, :1] , train_data[:, 1] 
    size = size * 0.8
    test_data = generate_fake_sin(int(size))
    test_x , test_y =  test_data[:, :1] , test_data[:, 1]

    return tarin_x , train_y , test_x , test_y


#generate data just like bishop book examples
def generate_fake_sin(size) :
  random_array = np.random.normal(0.0, .10, size)
  data = np.zeros(shape=(size,2))
  for i in range(size):
    x = random.random()
    num = math.pi * 2 * x
    sin_num = math.sin(num)
    random_array[i] = sin_num + random_array[i]
    data[i] = [ x , random_array[i] ]  
  return data


def get_data_weather():
    df=pd.read_csv('/content/weatherHistory.csv', sep=',')
    df = df.drop(['Formatted Date','Loud Cover' , 'Precip Type' ,'Summary' , 'Daily Summary'], axis='columns')
    mask = int(len(df) * 0.8)
    training_data = df[:mask]
    train_y = training_data['Humidity'] 
    train_x = training_data.drop(['Humidity'], axis='columns')
    #normalize train data
    a = -1
    b = 1
    #normalize test
    train_x = ((train_x - train_x.min())*(b-a)/(train_x.max() - train_x.min())) + a
   
    testing_data = df[mask:]
    test_y  = testing_data['Humidity'] 
    test_x  = testing_data.drop(['Humidity'], axis='columns')
    #normalize test
    test_x = ((test_x - test_x.min())*(b-a)/(test_x.max() - test_x.min())) + a
   
    return train_x.to_numpy() , list(train_y.to_numpy()) , test_x.to_numpy() ,list(test_y.to_numpy())

def draw_plot(train_x , train_y , test_x ,test_y):
    train_data_rmsd = []
    test_data_rmsd = []
    x = range(1,6)
    for i in x :
      model = polynomialRegression(degree = i)
      model.fit(train_x , train_y )
      Y_pred=model.predict(train_x)
      train_data_rmsd.append(model.root_mean_square_deviation(train_y , Y_pred))

      Y_pred=model.predict(test_x)
      test_data_rmsd.append(model.root_mean_square_deviation(test_y , Y_pred))


    plt.plot( x,train_data_rmsd ,marker="o", color = 'blue' )
    plt.plot( x,test_data_rmsd ,marker="o", color = 'orange' )
    plt.legend(["train", "test"])

    plt.show() 


if __name__ == "__main__":

    train_x , train_y , test_x ,test_y = get_data_weather()
    draw_plot(train_x , train_y , test_x ,test_y)